[English](README.md)

# TextureChannelPacker

**TextureChannelPacker** は、個別のグレースケールテクスチャを1枚の出力テクスチャの R (赤)、G (緑)、B (青)、A (アルファ) チャンネルに効率的にパッキングするための Unreal Engine 5.7 用プラグインです。ORM（オクルージョン、ラフネス、メタリック）マップや、その他のチャンネルパッキングテクスチャを作成する際によく使用されます。

>  **初めての方はこちら！ [クイックスタートガイド](QUICK_START.ja.md) をご覧ください。**

## 機能

- **4チャンネルパッキング (RGBA)**: 最大4枚の入力テクスチャを受け取り、それぞれの赤 (Red) チャンネルを出力テクスチャの R、G、B、A チャンネルに割り当てます。
- **自動リサイズ**: 指定されたターゲット解像度に合わせて、入力テクスチャを自動的にリサイズします。リサイズ処理には高品質なバイリニア補間（`FImageUtils`）が使用されます。
- **入力処理**:
  - 各ソーステクスチャから **Redチャンネル** の値を読み取ります。
  - 入力テクスチャが指定されていない場合、対応する R/G/B チャンネルは黒（0）で埋められます。
  - **Alphaチャンネル (任意)**: Alpha用のテクスチャが指定された場合、その Red チャンネルを使用します。空の場合は、Alphaチャンネルはデフォルトで白（255 / 不透明）に設定されます。
- **拡張フォーマットサポート**:
  - **16bit グレースケール** および **32bit Float (SDF)** のソースフォーマットをサポートしており、「テクスチャが真っ黒になる」問題を防ぎ、高精度なデータを正しく処理します。
- **出力設定**:
  - **圧縮設定**: ドロップダウンメニューから `Masks (推奨)`、`Grayscale`、`Default` を選択できます。
  - 出力先のパス、ファイル名、解像度をカスタマイズ可能です。
  - `sRGB = false` (リニアカラー) で `UTexture2D` アセットを生成します。
- **ユーザーインターフェース**:
  - **UIローカライズ**: エディタの言語設定に合わせて、UIや通知が自動的に日本語/英語に切り替わります。
  - **パスピッカー**: 出力パスの横にあるフォルダアイコンボタンを使用して、コンテンツブラウザから保存先ディレクトリを簡単に選択できます。
  - **トースト通知**: ログメッセージだけでなく、成功やエラーを分かりやすい通知（トースト通知）でフィードバックします。
  - Unreal Engine エディタの **Tools (ツール)** メニューに統合されています。

## 要件

- **Unreal Engine 5.5以上** (5.7で開発およびテスト済み)
- C++ プロジェクト (プラグインのコンパイルに必要)

## 簡単な解説: なぜチャンネルパッキングをするの？

- **サンプラー数の節約**: マテリアルが同時に読み込めるテクスチャの数には制限（通常は16枚）があります。3枚のテクスチャ（AO、ラフネス、メタリック）を1枚にまとめることで、サンプラーのスロットを節約し、マテリアルのエラー（Texture Sampler out of bounds）を防ぎます。
- **メモリ効率**: 複数のファイルを別々に読み込むよりも、1つにまとめることでメモリのオーバーヘッドを削減できます。
- **ファイル管理**: ファイル数が減るため、コンテンツブラウザが整理され、管理しやすくなります。

## 対応フォーマット

このツールは多様なソーステクスチャ形式をサポートしており、様々なワークフローに対応しています。

- **8-bit**: `BGRA8`, `Gray8 (G8)` - 標準的なテクスチャ形式。
- **16-bit**: `Gray16 (G16)` - 高精度が必要な **ハイトマップ** に便利です。
- **Float**: `R16F`, `R32F`, `RGBA32F` - **SDF (Signed Distance Fields)** や **LUT** に便利です。

## 制限事項

- **浮動小数点テクスチャ**: 浮動小数点テクスチャ（SDFやハイトマップ等）は、パッキング時に **0.0 - 1.0 の範囲にクランプ（切り捨て）** されます。この範囲外の値はクリップされます。

## インストール方法

1. **クローンまたはダウンロード**:
   このリポジトリをダウンロードし、`TextureChannelPacker` フォルダをプロジェクトの `Plugins` ディレクトリに配置してください。
   - `Plugins` フォルダが存在しない場合は、プロジェクトのルートディレクトリ（`.uproject` と同じ階層）に作成してください。

   ディレクトリ構成:
   ```
   MyProject/
   ├── MyProject.uproject
   ├── Plugins/
   │   └── TextureChannelPacker/
   │       ├── TextureChannelPacker.uplugin
   │       └── Source/
   └── Source/
   ```

2. **プロジェクトファイルの生成**:
   `.uproject` ファイルを右クリックし、**Generate Visual Studio project files** を選択します。

3. **プロジェクトのビルド**:
   生成された `.sln` ファイルを IDE（Visual Studio や Rider など）で開き、プロジェクトをビルドします。これによりプラグインがコンパイルされます。

4. **プラグインの有効化**:
   Unreal Engine エディタを起動します。プラグインが自動的に有効になっていない場合は、**Edit (編集) > Plugins (プラグイン)** から **TextureChannelPacker** を検索して有効にしてください。再起動を求められた場合はエディタを再起動します。

## 使用方法

1. **ツールの起動**:
   Unreal Editor のメインメニューバーから **Tools (ツール) > Texture Packing** を選択します。Texture Channel Packer タブが開きます。このタブはエディタレイアウトの任意の場所にドッキングできます。

2. **入力の割り当て**:
   - **Red Channel Input**: 出力の Red チャンネルに格納するテクスチャを選択します（例: アンビエントオクルージョン）。
   - **Green Channel Input**: 出力の Green チャンネルに格納するテクスチャを選択します（例: ラフネス）。
   - **Blue Channel Input**: 出力の Blue チャンネルに格納するテクスチャを選択します（例: メタリック）。
   - **Alpha Channel Input** (任意): 出力の Alpha チャンネルに格納するテクスチャを選択します。空の場合、デフォルトで白 (255) になります。

   *注意: コンテンツブラウザからアセットを直接ドラッグ＆ドロップすることも可能です。また、入力は空のままでも構いません。その場合、R/G/B チャンネルは黒で埋められます。*

3. **出力設定**:
   - **Resolution**: 出力テクスチャの解像度を設定します（例: 2048）。
   - **Compression Settings**: 圧縮タイプを選択します（デフォルトは `Masks`）。
   - **Output Path**: アセットを保存するゲームフォルダのパスを指定します。手動で入力するか、**フォルダアイコン** をクリックしてコンテンツブラウザから選択できます。
   - **File Name**: 新しいテクスチャアセットのファイル名を入力します。

4. **生成**:
   **Generate Texture** ボタンをクリックします。
   - ツールがテクスチャを処理し、指定された場所に新しいアセットをコンテンツブラウザ内に作成します。
   - 処理が完了すると、成功または失敗を知らせるトースト通知が表示されます。

## 圧縮設定の解説

| 設定名 | 最適な用途 | 説明 |
| :--- | :--- | :--- |
| **Masks (推奨)** | **ORMマップ**、パック済みマスク | sRGBを無効化し、チャンネル間の干渉を防ぎます。PBRワークフローに最適です。 |
| **Grayscale** | **ハイトマップ**、単一マスク | リニア値を保持します。1チャンネルのデータに適しています。 |
| **Default** | カラーテクスチャ | 標準的な圧縮です。通常はアルベド（カラー）用であり、チャンネルパッキングには推奨されません。 |

## ライセンス

このプロジェクトは MIT ライセンスの下で公開されています。詳細は [LICENSE](LICENSE) ファイルを参照してください。
